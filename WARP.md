# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project overview

This is a Flutter proof-of-concept app that discovers and connects to an Accu-Chek Instant Bluetooth glucose meter and decodes live glucose measurements.

Key pieces:
- `lib/main.dart`: Single entrypoint containing the entire app, including the root `MyApp` widget and the `ScannerPage` Bluetooth UI/logic.
- `android/`, `ios/`: Standard Flutter platform projects; they use the config generated by Flutter tooling and typically do not contain custom logic specific to this PoC.
- `test/widget_test.dart`: Default Flutter widget smoke test that currently does **not** reflect the actual `ScannerPage` UI.

Dependencies (see `pubspec.yaml`):
- `flutter_blue_plus`: Bluetooth Low Energy (BLE) scanning, connections, and GATT characteristic subscriptions.
- `flutter_lints`: Provides the lint rules referenced from `analysis_options.yaml`.

## Architecture and code structure

### App entry and theming

- `main()` in `lib/main.dart` calls `runApp(const MyApp())`.
- `MyApp` is a `StatelessWidget` that configures a `MaterialApp` with:
  - Title `Accu-Chek Instant Scanner`.
  - Material 3 theme using a deep purple seed color.
  - `home` set to a single `ScannerPage` screen.

If you add navigation or multiple screens, you will extend or refactor `MyApp` (e.g., by introducing named routes or a `Navigator`-driven structure) and pull new widgets out of `ScannerPage` into separate files under `lib/`.

### Bluetooth scanning and device selection

All BLE logic is contained in `ScannerPage` (a `StatefulWidget`) and its `_ScannerPageState`:

- State fields:
  - `_scanResults`: List of `ScanResult` values from `flutter_blue_plus` filtered to Accu-Chek-like device names.
  - `_isScanning`: Whether an active scan is running.
  - `_connectedDevice`: Currently connected `BluetoothDevice`, if any.
  - `_glucoseReading`: Last decoded glucose reading as a display string.
  - `_status`: Human-readable status shown in the UI.

- Scanning flow (`_startScan`):
  - Resets UI state, clears results, and sets `_status` to indicate scanning.
  - Waits for `FlutterBluePlus.adapterState` to reach `BluetoothAdapterState.on` before starting the scan.
  - Subscribes to `FlutterBluePlus.onScanResults`, then filters results whose advertisement name contains `"accu-chek instant"`, `"accu-chek"`, or `"accu chek"` (case-insensitive).
  - Stores only the filtered results in `_scanResults` and updates the list view.
  - Uses `FlutterBluePlus.cancelWhenScanComplete(subscription)` so the scan-result listener is automatically cancelled when scanning ends.
  - Calls `FlutterBluePlus.startScan(...)` with a 10-second timeout, low-latency Android scan mode, and `withNames` limited to `['Accu-Chek Instant']`.
  - When the scan completes, updates `_status` based on whether any devices were found.

When modifying scanning behavior or adding filters, adjust `_startScan` and its on-scan listener. Keep the filtering and `cancelWhenScanComplete` semantics aligned to avoid memory leaks and stale state.

### Connection, services, and notifications

Device selection and connection are handled by `_connectAndListen(ScanResult result)`:

- Stops scanning before connecting.
- Connects to the chosen `BluetoothDevice` with a 15-second timeout and stores it in `_connectedDevice`.
- Discovers GATT services and searches for:
  - Glucose Service UUID: `00001808-0000-1000-8000-00805f9b34fb`.
  - Glucose Measurement Characteristic UUID: `00002a18-0000-1000-8000-00805f9b34fb`.
- If the characteristic is not found, updates `_status` and disconnects.
- If found, it:
  - Subscribes to `measurementCharacteristic.onValueReceived`.
  - For each notification, decodes the payload via `_decodeGlucoseMeasurement` and updates `_glucoseReading` and `_status`.
  - Uses `device.cancelWhenDisconnected(subscription)` so the notification listener is cleaned up automatically when the device disconnects.
  - Enables notifications via `measurementCharacteristic.setNotifyValue(true)`.

All connection- and notification-related state updates should flow through `_connectAndListen` and `_disconnect` to keep UI and underlying BLE state consistent.

### Glucose measurement decoding

The decoding logic is implemented in three helper methods on `_ScannerPageState`:

- `_decodeGlucoseMeasurement(List<int> data)`:
  - Expects at least 3 bytes.
  - Treats `data[0]` as flags and `data[1..2]` as an IEEE-11073 16-bit SFLOAT representing glucose concentration.
  - Delegates to `_decodeSfloat` to parse the numeric value.
  - Checks the lowest flag bit to infer units (mmol/L vs. mg/dL) and, when needed, converts mmol/L to mg/dL using a constant conversion factor.
  - Returns a formatted string summarizing the value and units.

- `_decodeSfloat(int lowByte, int highByte)`:
  - Combines the two bytes into a 16-bit value.
  - Extracts a 12-bit mantissa and 4-bit exponent, performs sign extension on each, and delegates to `pow10` for exponentiation.

- `pow10(int exponent)`:
  - Computes 10^exponent using a simple loop, supporting positive and negative exponents.

If you change how glucose values are decoded (e.g., to reflect a more accurate device-specific spec), keep the SFLOAT, exponent-handling, and unit-conversion responsibilities localized to these methods.

### UI layout and state lifecycle

The widget tree for `ScannerPage` is a single `Scaffold` with:
- `AppBar` title: `Accu-Chek Instant Scanner PoC`.
- A `Column` body with:
  - A status `Text` bound to `_status`.
  - A primary `ElevatedButton` that triggers `_startScan` and is disabled while `_isScanning` is true.
  - A conditional `Expanded` list of devices when `_scanResults` is not empty. Each `ListTile` displays the device name (or `(unnamed)` fallback), its remote ID, RSSI, and calls `_connectAndListen` on tap.
  - A conditional section showing `_glucoseReading` in a prominent style when present.
  - A conditional `Disconnect` button when `_connectedDevice` is non-null, wired to `_disconnect`.

Lifecycle:
- `initState` sets an initial `_status` of `Idle`.
- `dispose` calls `_disconnect()` before delegating to `super.dispose()` to ensure active connections are closed when leaving the page.

When adding new UI elements related to connection status or readings, prefer to hang them off existing state fields (`_status`, `_glucoseReading`, `_connectedDevice`, `_scanResults`) rather than introducing parallel sources of truth.

## Linting and static analysis

- Lints are configured via `analysis_options.yaml`, which includes `package:flutter_lints/flutter.yaml` without further custom rules.
- To run static analysis:
  - `flutter analyze`

When changing code, keep in mind that new rules may be enabled in `analysis_options.yaml` in the future; prefer code patterns that work well with the standard Flutter lint set.

## Formatting

- Dart/Flutter formatting is not customized beyond the default.
- To format code consistently:
  - Format everything: `dart format lib test`
  - Or format a single file: `dart format lib/main.dart`

## Testing

Current tests:
- `test/widget_test.dart` is the stock Flutter counter example test and does not match the actual UI in `ScannerPage`.

Commands:
- Run all tests:
  - `flutter test`
- Run a single test file (recommended pattern when adding tests):
  - `flutter test test/widget_test.dart`
- Filter by test name using `--plain-name` if you introduce multiple tests in a file:
  - `flutter test --plain-name "some description" test/widget_test.dart`

If you significantly change the UI (for example, by removing the counter), either update or replace `widget_test.dart` so CI or local workflows do not fail due to the outdated sample test.

## Running and building the app

All standard Flutter commands apply; there are no custom scripts or wrappers.

Common commands:
- Fetch dependencies:
  - `flutter pub get`
- Run the app on an attached device or emulator:
  - `flutter run`
- Run in release mode:
  - `flutter run --release`
- Build release artifacts (platform-specific):
  - Android APK: `flutter build apk`
  - iOS (from macOS with Xcode): `flutter build ios`

Use the appropriate `-d` flag with `flutter run` if you have multiple devices available (e.g., emulators and physical devices).